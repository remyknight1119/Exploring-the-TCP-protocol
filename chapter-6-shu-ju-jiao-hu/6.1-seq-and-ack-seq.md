# 6.1 Seq and ACK Seq

　　由前文可知，TCP的序列号（seq）与确认号（ack\_seq）都是无符号32的整数。seq用于为每一字节TCP数据编号（SYN和FIN标记位也会占用一个seq）；ack\_seq用于告知数据发送端：“接收端已经收到了ack\_seq - 1号数据，请发送ack\_seq号数据”。下面我们重温一下TCP连接建立和数据传输过程，在这个过程中探究一下seq和ack\_seq是如何使用的。首先来介绍一下tcp\_sock中与seq和ack\_seq相关的主要成员：&#x20;

```c
34 struct tcp_sock {
135     /* inet_connection_sock has to be the first member of tcp_sock */
136     struct inet_connection_sock inet_conn;
...
151     u32 rcv_nxt;    /* What we want to receive next     */
152     u32 copied_seq; /* Head of yet unread data      */
153     u32 rcv_wup;    /* rcv_nxt on last window update sent   */
154     u32 snd_nxt;    /* Next sequence we send        */
155 
156     u32 snd_una;    /* First byte we want an ack for    */
157     u32 snd_sml;    /* Last byte of the most recently transmitted small packet */
...
182     u32 snd_wl1;    /* Sequence for window update       */
...
240     u32 write_seq;  /* Tail(+1) of data held in tcp send buffer */
241     u32 pushed_seq; /* Last pushed seq, required to talk to windows */
...
281     u32 urg_seq;    /* Seq of received urgent pointer */
...
```

　　这些成员的作用都有英文注释来说明，就不翻译了。

　　TCP连接的首个SYN包中的序列号被称为初始序列号(ISN)，来看看ISN是如何生成的，先看发送SYN时：

```c
 142 int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 143 {
...
 237     if (!tp->write_seq && likely(!tp->repair))
 238         tp->write_seq = secure_tcp_sequence_number(inet->inet_saddr,
 239                                inet->inet_daddr,
 240                                inet->inet_sport,
 241                                usin->sin_port);　//生成初始序列号
...
```

　　ISN的生成用到了源|目的IP和源|目的端口，这样就保证了“连接不同但ISN相同”的概率是很低的。来看secure\_tcp\_sequence\_number函数：

```c
105 __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
106                  __be16 sport, __be16 dport)
107 {        
108     u32 hash[MD5_DIGEST_WORDS]; 
109 
110     hash[0] = (__force u32)saddr;
111     hash[1] = (__force u32)daddr;
112     hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
113     hash[3] = net_secret[15];
114 
115     md5_transform(hash, net_secret);
116 
117     return seq_scale(hash[0]);
118 }    
```

　　其中，md5\_transform函数所使用的net\_secret是个全局变量，其中的数据由net\_secret\_init函数来随机填充：

```c
 13 static u32 net_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;
 14 
 15 void net_secret_init(void)
 16 {
 17     get_random_bytes(net_secret, sizeof(net_secret));
 18 }
```

　　net\_secret\_init函数由build\_ehash\_secret函数调用，而socket系统调用在使用inet\_create函数时会调用build\_ehash\_secret：

```c
 277 static int inet_create(struct net *net, struct socket *sock, int protocol,
 278                int kern)
 279 {
 280     struct sock *sk;
 281     struct inet_protosw *answer;
 282     struct inet_sock *inet;
 283     struct proto *answer_prot;
 284     unsigned char answer_flags;
 285     char answer_no_check;
 286     int try_loading_module = 0;
 287     int err;
 288 
 289     if (unlikely(!inet_ehash_secret))
 290         if (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)
 291             build_ehash_secret();
...
```

　　这样对于任意一个TCP scoket，其ISN与另一个TCP socket相同的概率都是很低的。如果一条TCP连接关闭后很快再建立一个相同源|目IP和port的连接，由于ISN不同使得新连接的数据落入旧连接合法seq范围的概率大大降低，从而也减小了新旧连接的互相伤害。

　　接下来我们看ISN是如何使用的：

```c
2925 int tcp_connect(struct sock *sk)
2926 {
2927     struct tcp_sock *tp = tcp_sk(sk);
2928     struct sk_buff *buff;
2929     int err;
2930 
2931     tcp_connect_init(sk);
...
2945     tcp_init_nondata_skb(buff, tp->write_seq++, TCPHDR_SYN);
...
2947     tcp_connect_queue_skb(sk, buff);　//将SYN放入队列中
...
2951     err = tp->fastopen_req ? tcp_send_syn_data(sk, buff) :
2952           tcp_transmit_skb(sk, buff, 1, sk->sk_allocation);　//发送SYN
2953     if (err == -ECONNREFUSED)
2954         return err;
2955 
2956     /* We change tp->snd_nxt after the tcp_transmit_skb() call
2957      * in order to make this packet get counted in tcpOutSegs.
2958      */
2959     tp->snd_nxt = tp->write_seq;　//snd_nxt = ISN + 1
2960     tp->pushed_seq = tp->write_seq;
...
```

　　tcp\_connect\_init函数中会初始化一些与seq相关的成员：

```c
2752 void tcp_connect_init(struct sock *sk)
2753 {
...
2803     tcp_init_wl(tp, 0);　//tp->snd_wl1 = 0
2804     tp->snd_una = tp->write_seq;
2805     tp->snd_sml = tp->write_seq;
2806     tp->snd_up = tp->write_seq;
2807     tp->snd_nxt = tp->write_seq;
...
```

　tcp\_init\_nondata\_skb函数会将seq记录在skb中：

```c
 356 static void tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags)
 357 {
 ... 
 368     TCP_SKB_CB(skb)->seq = seq;
 369     if (flags & (TCPHDR_SYN | TCPHDR_FIN))
 370         seq++; 　//SYN和FIN都会占用一个seq
 371     TCP_SKB_CB(skb)->end_seq = seq;　
 372 }
```

　tcp\_connect\_queue\_skb函数不只是将skb加入到发送队列中：

```c
2821 static void tcp_connect_queue_skb(struct sock *sk, struct sk_buff *skb)
2822 {
2823     struct tcp_sock *tp = tcp_sk(sk);
2824     struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
2825 
2826     tcb->end_seq += skb->len;　//如果有数据则将数据编号；end_seq实际上是下一个字节数据的seq
2827     skb_header_release(skb);
2828     __tcp_add_write_queue_tail(sk, skb);　//加入到发送队列
2829     sk->sk_wmem_queued += skb->truesize;　//更新队列中缓存占用总大小
2830     sk_mem_charge(sk, skb->truesize);　//更新socket中已申请内存的信息
2831     tp->write_seq = tcb->end_seq;　//记录已经写入发送缓存的最后一个字节的seq
2832     tp->packets_out += tcp_skb_pcount(skb);　//记录TCP发送出去但未被接收的报文的数量
2833 }
```

　　tcp\_transmit\_skb函数在发送skb时会将seq和ack\_seq写入报文：

```c
 828 static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
 829                 gfp_t gfp_mask)
 830 {
 831     const struct inet_connection_sock *icsk = inet_csk(sk);
...
 898     th->seq         = htonl(tcb->seq);
 899     th->ack_seq     = htonl(tp->rcv_nxt);
...
```

&#x20;       client发送的SYN到达server端后，server的TCP也要选择序列号作为SYN|ACK的ISN，同时需要设置ack\_seq。看看这些是怎么做的：

```c
1465 int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)
1466 {
...
1523     tcp_openreq_init(req, &tmp_opt, skb);
...
1576         isn = tcp_v4_init_sequence(skb);
1577     }
1578     tcp_rsk(req)->snt_isn = isn;
...
1598     skb_synack = tcp_make_synack(sk, dst, req,
1599         fastopen_cookie_present(&valid_foc) ? &valid_foc : NULL);
...
```

　　在连接建立完成之前，server端保存连接信息的是request\_sock，tcp\_openreq\_init函数负责对其进行初始化：

